use lazy_static::lazy_static;
use pairing_ce::{
    bn256::fr::{Fr, FrRepr},	
};
use std::vec::Vec;
use ff_ce::{Field, PrimeField, PrimeFieldRepr};

lazy_static! {
    static ref MIMC7_CONSTANT: Vec<Fr> = Mimc5::generate_constants();
}

/// MIMC7 is a hash function suited for BN256's scalar field.
///
/// It has modulus
/// p = 21888242871839275222246405745257275088548364400416034343698204186575808495617
///
/// The MIMC paper (https://eprint.iacr.org/2016/492.pdf) states that monomial x^d is a permutation
/// in Fp if gcd(d,p) == 1
///
/// Exponent for MIMC7 is 5, which satisfies the above condition.
/// MIMC can't be implemented generically as different
/// prime fields will require different MIMC implementations.
///
/// ```code
/// pseudo code:
/// fn mimc5_permutation(constants, x, k):
///    h := x;
///    for i = 0..constants.len() {
///        h := h + k + constants[i]
///        h := h^5;
///    }
///    h = h + k;
///    return h;
/// ```
#[derive(Copy, Clone, Debug)]
pub struct Mimc5 {
    pub(crate) state: Fr,
}

const BLOCK_SIZE: usize = 32;


#[no_mangle]
pub extern "C" fn compute(
    i: *const ::std::os::raw::c_char,
    i_len: u32,
    o: *mut ::std::os::raw::c_char
){
    let input_i8: &[i8] = unsafe { std::slice::from_raw_parts(i, i_len as usize) };
    let input_slice: &[u8] = unsafe { std::mem::transmute(input_i8) };

    let raw_out_i8: &mut [i8] = unsafe { std::slice::from_raw_parts_mut(o, 32 as usize) };
    let mut raw_out: &mut [u8] = unsafe { std::mem::transmute(raw_out_i8) };

    let digest: Vec<u8> = mimc_hash(&input_slice);
    raw_out.copy_from_slice(&digest);
}

// User-friendly function to evaluate the MiMC hash of a string
pub fn mimc_hash<T : AsRef<[u8]>>(bytes: T) -> Vec<u8> {

    let mut hasher = Mimc5::initialize();
	let slice = bytes.as_ref().to_vec();

	slice
		// break the input slice in chunks of `BLOCK_SIZE` width 
		.chunks(BLOCK_SIZE)
		// feed each chunk to the hash by interpreting it as a big-endian integer
		.scan(&mut hasher, |state, chunk: &[u8]| -> Option<Fr> {
			let mut c = chunk;
			let mut larger_c: Vec<u8>;

			// If the last chunk is smaller than, the blocksize. We complete
			// it using left padding.
			if c.len() < BLOCK_SIZE {
				larger_c = Vec::with_capacity(BLOCK_SIZE);
				larger_c.extend_from_slice(&vec![0; BLOCK_SIZE - c.len()]);
				larger_c.extend_from_slice(c);
				c = &larger_c;
			}

			// Cast it as a field element. Note, we panic here because there is 
			// nothing to do if we encounter a bad input. The design of the 
			// state-manager designs prevents this to happen already.
			let mut x = FrRepr::from(0);
			x.read_be(c).expect("Fatal : invalid field element");
			let fr = Fr::from_repr(x).expect("could not convert repr into fr");
			state.update_scalar(&fr);
			return Some(state.state)
		})
		// Consume the iterator silently
		.for_each(drop);

	// Collect the result from the hasher and cast into a big-endian bytes string
	let fr_digest = hasher.finalize();
	let mut res = Vec::with_capacity(BLOCK_SIZE);
	fr_digest.into_repr().write_be(&mut res).expect("could not write the resulting slice");

	// Sanity-check : ensures the result buffer has been correctly filled.
	if res.len() != BLOCK_SIZE {
		panic!("did not write the buffer correctly");
	}

	return res
}

impl Mimc5 {
    fn generate_constants() -> Vec<Fr> {
        let constants_str = [
        "227063593160049201514509818732644766896230235191445544141110657236065169432",
		"14216930871394413475885543358391969001796912808625170576412941718425727480905",
		"13091462576550089354261023627641753004926491134347784566278243144585841078417",
		"18736023174290548165050765799231505541711012637972192037099796877637059010016",
		"796636033841689627732941016044857384234234277501564259311815186813195010627",
		"7049792165217502363114227773374115492495393176744730189515562778035071867821",
		"17004095116726405864684454804540866859059278240914071423178037737714962317801",
		"14110268636549425055632566045581853560423521131037962488540655987535191004969",
		"18183635788335456259215276538456634373878691301055828686319747253615002143747",
		"17094270359512653934788537386985943119745071422450083986863088746253169651698",
		"21606397331421151312290269496743528579353487580150269962583704985025203683566",
		"11482796835106945909650417409009375869128464918808201005317159508926845333372",
		"5896114894234359837481980051604224653571872854250471410846947653395077045175",
		"8043758726292679243102809161324039047742869268808278302475346342056293903111",
		"9765227797118338345724719313674898871992672983681676861011354974715998221736",
		"9980184672909482180637695009382192818723793158333771031442726952979088300949",
		"8231877132811199596376758288825197494440517476607659739835166243301765860904",
		"8335067676479817842493472758560802142744298375820509901958843910507461215099",
		"10841545820231554131682518174137979197520487236302295350589030622478073612580",
		"3219131731887960949807515150723614694444414566887389129377006765182004280513",
		"56804755552986645089184612629551548380712103263713508879501466305875964502",
		"3063594241115875600174308534745809602942823704041628148569154884406804087107",
		"1022229143886614551843240999132524298883977051285206014564945818204512723699",
		"1247948173836835613759834564361354902760693928209107555848903547602125609667",
		"12690047342343207986715505449836807591806230840704578918412884362668236488424",
		"9456585747207468967136341612034989517427340607940281880317747335469436896657",
		"10555679902623742965715379393380415053883065457992409910544092743581080934995",
		"7642145723831431937150654031296178463709608595366450210492201904757626429246",
		"12796285368351778411157416332578703705714646412236885840835353324717839499288",
		"9920917725324856014628946457815467011979864273734012436016568174149575073620",
		"1806771888767844400796964154165462987833794566790129616905621802681918305653",
		"2237188035570518200375801347148339263941951653352635838130411033524031543911",
		"6159774869789305950383877854134202099758528146886459191738581516739660641536",
		"2159153222189174173490067225063044363535871059524538695070191871847470955412",
		"3796681237523026223086145426486778389352604372052172299127843115700063953978",
		"15056204194454071177732947070380798505823141690312550077512103668193190650776",
		"18847697144542616776597460523489465741015527416695791143858315271487053716345",
		"6010749183509972177829296064870149897270623093292652040160770247410917400713",
		"18573886017870388584791853665036341308998474745558018999552747786306327187163",
		"1902990407634160450975366476679732066298558065179856843056247078583090353402",
		"5056480146405086811789505170440731715530475328844870175949109998024731067467",
		"15740426253908866033612398810786354575055336092664709132388682334602601168702",
		"491250169370634115048394492066021687801835886554368663023106896215909698645",
		"5255739895973293668031562539559209975940249484631633008164126407281628232615",
		"2993874367492450065981125977298561936411381709727853908030896236122420343727",
		"1403914884782249096009089982237816316006749353131179527973160317711491651076",
		"12914056360493359423764695636160432190520475662743083737270395470517659710829",
		"2917404364788167044194419588360849732661365640462661072201491302974369825438",
		"20784103425950430825528915699354924111453274156179753313577396452562475630409",
		"1316449090346410801845183915381769525990226349513436734911941391785200212382",
		"19891032074353122751368091896719823139652894181016649395806048173493086857338",
		"5815046378509054585353936553633012260823210849110325320012946858007466529124",
		"9342667946085721753232292005472701104293420214150876291070202875265183228493",
		"3220266212393036831161802760991433604684006326671889836355824255100900631167",
		"5129486740981610555565012597292200072154542792843090445908325336406070684212",
		"10365499242482502687915472615946022335465942941657641380012062207514707672369",
		"4611075984531475563366272046528439696064144614475739366357201914182455577262",
		"12274444357037046733725220420843071726458636107722716111189924462679653993388",
		"2444021750719441015829197081940411467903641739650651394173044346750720208186",
		"15143675381185307178500906868356334825651015737618718091251777377451213407009",
		"12298344485990016534010212669317442637641970988734864662627733004522811247925",
		"407792086961455574135957029358146763364316705425829200860200716711144772110",
		"14686495456688325356229693863075020970632170023662416843806799342111029622608",
		"18951855733129374999539824238637835284715674696067944400774670287760774220945",
		"16334111234389595299193801902740634241244222168925513590632042896157659801559",
		"19623255796206582213343044956093476486139104852525580813879681620362890897558",
		"19284965820494284222482683988641716023855422844851137438394494268143521834633",
		"5042179171081431331282902567660865915154957134450098475064856996863766266700",
		"19075637350940522721481728672122652040982051980503549922053017343878171287859",
		"3096096603894689121667217859533027222641140852874591863405531829483163197840",
		"21543191916254714877479305695881635899536323218308582727971577317237448630394",
		"9980826669647369562409093155367822719846527509077693563581519695180055111612",
		"15696810051723434179520892802382061883123916463500679794859575791011338569408",
		"16710441142546269914456840870536846684666759198340322352862050391462853257859",
		"16784162115836373795735205525741716397089015491804805056190418507628689514930",
		"20919057090859990208154240431041177593233739098537292808899071595933232729923",
		"10599687814613664602758829894851759731719366381965307423459731431292674962169",
		"18092495413286015678790630168208787644418599959399842781132549515553139410584",
		"3711799916574241475420555831932793749725513171598155737019147179555971323932",
		"3878599345777774665565912098811702945088203032347412020650440180042070635932",
		"5221687210067764220342563941232799146265831780579450576980295260767640382879",
		"8572221995878907446339305767802962859956678949340179087676700081887070991418",
		"13250870432967790116799427082816480335296645135069568814513747123924233796635",
		"1762401353042500109291165674468304204146747021756564981770933537807125319114",
		"16297297017503580916701479288278297532093130260977290972316747472919454831982",
		"11301542023144145761538286188600886091507808962937720724476656305360091843144",
		"3226463335346792970204307734198400221579260082314988957001789813920653640539",
		"18201479370055215790852976435001157175848060363403485699590922691559044268816",
		"1421776804632889503250299670147988126727383540687678953592715279854500795359",
		"21230806036983379610681285136437154793727917065272091459526637553303154098111",
		"4890882571712671501605561097268997756779482040164834629188098947876004725416",
		"5593942559448006934122110327465529553527338130800655100545929619006646130703",
		"19858351320072490775901034833039724699209320536870921374639489244857675659132",
		"20569043303914081560731019065398457647606565616902130240528129599578592228968",
		"10079763651682455157739628234628529503046958675131789218119668348482240995889",
		"12075806963751214072241023676113780594016698427239126221026218940878020594099",
		"16943711675576883986628449992969978423674439022821403957709854115749711096791",
		"1649367951959654604433060041378790418650827672660780721804854858634469108499",
		"11957779911765486656644689149330846943313705416524223567398485006010159944456",
		"1467372234246581691639910443837800274464279239719080130524501855420568931562",
		"16345733847331835103389317805143010119891715846287496394786195665951149072330",
		"7448836565550394578623806516077867680872791214995424737491744252881969933895",
		"8650625054615070484889009442902102532553165757475036656003778307974620126687",
		"11907653828035696663714143522983869211190719525809271814618637057421334515531",
		"2886235945117591824771809965323805334808414280306969797067740169710933875743",
		"10917882835509774955453905588848475782845168316402655627358883243042341451042",
		"19971838851328344406118398405782812664383760583892867152477371808954818808044",
		"18265625854115489546229892300234363068277159796553916584413873595353870332297",
		"11541833244575501930159939361686046962070402099593978040285396521535417462043",
		"14681674628590376571212438852682626513594958603045820146231225156751765152354",
        ];

        let constants: Vec<_> = constants_str
            .iter()
            .map(|v| Fr::from_str(v).unwrap())
            .collect();

        constants
    }

    // Performs a symmetric MIMC encryption. It is used as a sub-part of the hash function.
    // m is the message to be encrypted, k is the encryption key
    #[inline(always)]
    pub fn encrypt(message: &Fr, k: &Fr) -> Fr {
        let mut cipher = *message;

        for cnst in MIMC7_CONSTANT.iter() {
            // let tmp = cipher.add(&k).add(cnst);
            cipher.add_assign(k);
            cipher.add_assign(cnst);
            // Raises cipher to power 5
            let tmp = cipher;
            cipher.square();
            cipher.square();
            cipher.mul_assign(&tmp);
        }

        cipher.add_assign(k);

        cipher
    }

    #[inline(always)]
    fn update_scalar(&mut self, block: &Fr) {
		// The update function corresponds to
		// new_state <- state + block + enc(block, key=state)
        let encrypted = Mimc5::encrypt(block, &self.state);
        self.state.add_assign(&encrypted);
        self.state.add_assign(block);
    }

    #[inline(always)]
    fn initialize() -> Self {
        Self {
            state: Fr::zero(),
        }
    }

    #[inline(always)]
    fn finalize(self) -> Fr {
        self.state
    }
}

#[test]
fn test_hasher_zero() {
	// Hashing zero
	let mut hasher = Mimc5::initialize();
	hasher.update_scalar(&Fr::zero());
	let digest = hasher.finalize();
	assert_eq!(digest.into_repr().to_string(), "0x2c7298fd87d3039ffea208538f6b297b60b373a63792b4cd0654fdc88fd0d6ee");
}

#[test]
fn test_hasher_one() {
	// Hashing one
	let mut hasher = Mimc5::initialize();
	hasher.update_scalar(&Fr::one());
	let digest = hasher.finalize();
	assert_eq!(digest.into_repr().to_string(), "0x27e5458b666ef581475a9acddbc3524ca252185cae3936506e65cda9c358222b");
}

#[test]
fn test_long_string() {

	// The input slice is equivalent to concatenating 16 field element onto each other.
	let mut input_slice = vec![0u8; BLOCK_SIZE*16];
	for i in 0..16 {
		input_slice[BLOCK_SIZE*(i+1)-1] = i as u8
	}

	// Parse the digest back into a field element
	let digest: Vec<u8> = mimc_hash(&input_slice);
	let digest_slice: &[u8] = digest.as_ref();
	let mut fr_digest: FrRepr = FrRepr::from(0); // dummy initialization
	fr_digest.read_be(digest_slice).expect("could not deserialize the result of the hasher");

	assert_eq!(fr_digest.to_string(), "0x145875dd085ea2fb9796333e55c9da80228eb321df0ca9a41ca64ba6fe90b167");
}
